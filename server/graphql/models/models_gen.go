// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/elisalimli/go_graphql_template/validator"
)

type IFormResponse interface {
	IsIFormResponse()
	GetOk() bool
	GetErrors() []*validator.FieldError
}

type AuthResponse struct {
	Ok        bool                    `json:"ok"`
	Errors    []*validator.FieldError `json:"errors,omitempty"`
	AuthToken *AuthToken              `json:"authToken,omitempty"`
	User      *User                   `json:"user,omitempty"`
}

func (AuthResponse) IsIFormResponse() {}
func (this AuthResponse) GetOk() bool { return this.Ok }
func (this AuthResponse) GetErrors() []*validator.FieldError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*validator.FieldError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AuthToken struct {
	Token     string    `json:"token"`
	ExpiredAt time.Time `json:"expiredAt"`
}

// The `UploadFile` type, represents the request for uploading a file with a certain payload.
type CreatePostInput struct {
	Files          []*UploadFile      `json:"files,omitempty"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	Variant        string             `json:"variant"`
	Language       LanguageType       `json:"language"`
	SecondLanguage SecondLanguageType `json:"secondLanguage"`
	Grade          int                `json:"grade"`
	Type           Type               `json:"type"`
}

type CreatePostResponse struct {
	Ok     bool                    `json:"ok"`
	Errors []*validator.FieldError `json:"errors,omitempty"`
	Post   *Post                   `json:"post,omitempty"`
}

func (CreatePostResponse) IsIFormResponse() {}
func (this CreatePostResponse) GetOk() bool { return this.Ok }
func (this CreatePostResponse) GetErrors() []*validator.FieldError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*validator.FieldError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The `File` type, represents the response of uploading a file.
type File struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Content     string `json:"content"`
	ContentType string `json:"contentType"`
}

type FormResponse struct {
	Ok     bool                    `json:"ok"`
	Errors []*validator.FieldError `json:"errors,omitempty"`
}

type GoogleLoginOrSignUpInput struct {
	Token       string  `json:"token"`
	Username    *string `json:"username,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type PostsInput struct {
	Cursor *string `json:"cursor,omitempty"`
	Limit  *int    `json:"limit,omitempty"`
}

type RegisterInput struct {
	Username        string `json:"username"`
	Email           string `json:"email"`
	Password        string `json:"password"`
	ConfirmPassword string `json:"confirmPassword"`
	FirstName       string `json:"firstName"`
	LastName        string `json:"lastName"`
	PhoneNumber     string `json:"phoneNumber"`
}

type SendOtpInput struct {
	To string `json:"to"`
}

// The `UploadFile` type, represents the request for uploading a file with certain payload.
type UploadFile struct {
	ID   int            `json:"id"`
	File graphql.Upload `json:"file"`
}

type VerifyOtpInput struct {
	To   string `json:"to"`
	Code string `json:"code"`
}

type LanguageType string

const (
	LanguageTypeAze LanguageType = "AZE"
	LanguageTypeRu  LanguageType = "RU"
	LanguageTypeEng LanguageType = "ENG"
)

var AllLanguageType = []LanguageType{
	LanguageTypeAze,
	LanguageTypeRu,
	LanguageTypeEng,
}

func (e LanguageType) IsValid() bool {
	switch e {
	case LanguageTypeAze, LanguageTypeRu, LanguageTypeEng:
		return true
	}
	return false
}

func (e LanguageType) String() string {
	return string(e)
}

func (e *LanguageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LanguageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LanguageType", str)
	}
	return nil
}

func (e LanguageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SecondLanguageType string

const (
	SecondLanguageTypeEng SecondLanguageType = "ENG"
	SecondLanguageTypeRu  SecondLanguageType = "RU"
	SecondLanguageTypeAze SecondLanguageType = "AZE"
)

var AllSecondLanguageType = []SecondLanguageType{
	SecondLanguageTypeEng,
	SecondLanguageTypeRu,
	SecondLanguageTypeAze,
}

func (e SecondLanguageType) IsValid() bool {
	switch e {
	case SecondLanguageTypeEng, SecondLanguageTypeRu, SecondLanguageTypeAze:
		return true
	}
	return false
}

func (e SecondLanguageType) String() string {
	return string(e)
}

func (e *SecondLanguageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecondLanguageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecondLanguageType", str)
	}
	return nil
}

func (e SecondLanguageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Type string

const (
	TypeBuraxilis Type = "BURAXILIS"
	TypeBlok1     Type = "BLOK1"
	TypeBlok2     Type = "BLOK2"
	TypeBlok3     Type = "BLOK3"
	TypeBlok4     Type = "BLOK4"
)

var AllType = []Type{
	TypeBuraxilis,
	TypeBlok1,
	TypeBlok2,
	TypeBlok3,
	TypeBlok4,
}

func (e Type) IsValid() bool {
	switch e {
	case TypeBuraxilis, TypeBlok1, TypeBlok2, TypeBlok3, TypeBlok4:
		return true
	}
	return false
}

func (e Type) String() string {
	return string(e)
}

func (e *Type) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Type(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Type", str)
	}
	return nil
}

func (e Type) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
