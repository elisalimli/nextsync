package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"

	"github.com/99designs/gqlgen/graphql"
	myContext "github.com/elisalimli/nextsync/server/context"
	"github.com/elisalimli/nextsync/server/domain"
	"github.com/elisalimli/nextsync/server/graphql/models"
	customMiddleware "github.com/elisalimli/nextsync/server/middleware"
	"github.com/elisalimli/nextsync/server/validator"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

var (
	ErrInput = errors.New("input errors")
)

func (m *mutationResolver) Login(ctx context.Context, input models.LoginInput) (*models.AuthResponse, error) {
	isValid, errors := validation(ctx, input)
	fmt.Println(isValid, errors)
	if !isValid {
		return &models.AuthResponse{Ok: false, Errors: errors}, nil
	}
	return m.Domain.Login(ctx, input)
}

func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	fmt.Println(ctx.Value("currentUser"))
	fmt.Println("recieved from ios")
	return "hello world", nil
}

func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	currentUserId, _ := ctx.Value(customMiddleware.CurrentUserIdKey).(string)
	if currentUserId == "TOKEN_EXPIRED" {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Unauthorized: Token has expired",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})

		return nil, nil
	}
	user, err := r.Domain.UsersRepo.GetUserByID(ctx, currentUserId)
	if err != nil {
		return nil, nil
	}
	return user, nil
}

func (m *mutationResolver) Register(ctx context.Context, input models.RegisterInput) (*models.AuthResponse, error) {
	isValid, errors := validation(ctx, input)
	if !isValid {
		return &models.AuthResponse{Ok: false, Errors: errors}, nil
	}

	return m.Domain.Register(ctx, input)
}

type GoogleUserRes struct {
	ID         string `json:"id"`
	Email      string `json:"email"`
	Name       string `json:"name"`
	GivenName  string `json:"given_name"`
	FamilyName string `json:"family_name"`
}

func (m *mutationResolver) GoogleLoginOrSignUp(ctx context.Context, input models.GoogleLoginOrSignUpInput) (*models.AuthResponse, error) {
	endpoint := "https://www.googleapis.com/userinfo/v2/me"
	fmt.Println("en", endpoint)
	client := &http.Client{}
	req, _ := http.NewRequest("GET", endpoint, nil)
	header := "Bearer " + input.Token
	req.Header.Set("Authorization", header)
	res, googleErr := client.Do(req)
	if googleErr != nil {
		return &models.AuthResponse{Ok: false, Errors: []*validator.FieldError{{Message: domain.ErrSomethingWentWrong, Field: domain.GeneralErrorFieldCode}}}, nil
	}

	defer res.Body.Close()
	body, bodyErr := io.ReadAll(res.Body)
	if bodyErr != nil {
		log.Panic(bodyErr)
		return &models.AuthResponse{Ok: false}, nil
	}

	var googleBody GoogleUserRes
	json.Unmarshal(body, &googleBody)
	fmt.Println(googleBody)
	if googleBody.Email != "" {
		user, _ := m.Domain.UsersRepo.GetUserByEmail(ctx, googleBody.Email)

		// userExists, userExistsErr := getAndHandleUserExists(&user, googleBody.Email)
		fmt.Println(user)
		// if userExistsErr != nil {
		// utils.CreateInternalServerError(ctx)
		// return
		// }

		if user == nil && input.Username != nil && input.PhoneNumber != nil {
			fmt.Println("creating...", user)
			newUser := models.User{Email: googleBody.Email, SocialLogin: true, SocialProvider: "Google", Username: *input.Username, PhoneNumber: *input.PhoneNumber}
			// 	storage.DB.Create(&user)
			res, err := m.Domain.UsersRepo.DB.NewInsert().Model(&newUser).Returning("*").Exec(ctx)
			fmt.Println("create user res", res, err)
			// 	returnUser(user, ctx)
			// 	return
			// }
			// re-defining the new created user
			user = &newUser

			// return &models.AuthResponse{Ok: true, User: &newUser}, nil

			// if user.SocialLogin == true && user.SocialProvider == "Google" {
			// 	returnUser(user, ctx)
			// 	return
			// }

			// utils.CreateEmailAlreadyRegistered(ctx)
			// return
		}
		// if !user.Verified {
		// return &models.AuthResponse{Ok: true, User: user}, nil
		// } else {

		// returning the auth tokens if user is created or existed before
		if user != nil {
			newRefreshToken, err := user.GenRefreshToken()
			if err != nil {
				return nil, errors.New(domain.ErrSomethingWentWrong)
			}

			newAccessToken, err := user.GenAccessToken()
			if err != nil {
				return nil, errors.New(domain.ErrSomethingWentWrong)
			}
			user.SaveRefreshToken(ctx, newRefreshToken)
			return &models.AuthResponse{Ok: true, AuthToken: newAccessToken, User: user}, nil
		}
		// }
	}
	fmt.Println("case 4")

	return &models.AuthResponse{Ok: true}, nil

}
func (m *mutationResolver) RefreshToken(ctx context.Context) (*models.AuthResponse, error) {
	return m.Domain.RefreshToken(ctx)
}

func (m *mutationResolver) Logout(ctx context.Context) (bool, error) {
	rtCookie := http.Cookie{
		Name:   os.Getenv("COOKIE_REFRESH_TOKEN"),
		Path:   "/", // <--- add this line
		Value:  "",
		Secure: false,
	}
	writer, _ := ctx.Value(myContext.HttpWriterKey).(http.ResponseWriter)
	// saving cookie
	http.SetCookie(writer, &rtCookie)
	return true, nil
}

func (m *mutationResolver) SendOtp(ctx context.Context, input models.SendOtpInput) (*models.FormResponse, error) {
	isValid, errors := validation(ctx, input)
	if !isValid {
		return &models.FormResponse{Ok: false, Errors: errors}, nil
	}

	return m.Domain.SendOtp(ctx, input)
}

func (m *mutationResolver) VerifyOtp(ctx context.Context, input models.VerifyOtpInput) (*models.AuthResponse, error) {
	isValid, errors := validation(ctx, input)
	if !isValid {
		return &models.AuthResponse{Ok: false, Errors: errors}, nil
	}

	return m.Domain.VerifyOtp(ctx, input)
}
